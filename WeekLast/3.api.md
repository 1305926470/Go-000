

# API 设计规范

[TOC]

## 协议规范

内部服务之间的请求调用统一使用 gRPC， 使用 pb 序列化。

服务可以在其 IDL 规范中定义 RPC 方法。

走外网的 http 请求 使用 http2。

## 命名规范

服务名、接口名、包名、字段名等字段名称

- 要与业务意义相符，能见名知意，如订单 order，移除（remove）或销毁（destroy）。

- 做到简洁，直观，风格统一。

- 可以使用已被广泛接受的短语和（或）缩写。

    

**包名**为应用的标识(APP_ID)，用于生成 gRPC 请求路径，或者 proto 之间进行引用 Message。文件中声明的包名称应该与产品和服务名称保持一致。带有版本的 API 的软件包名称必须以此版本结尾。

- 例如 ：`my.package.v1`, `google.calendar.v3` 。

- RequestURL:` /<package_name>.<version>.<service_name>/{method}`



## API 版本兼容性要求

接口道定义中，需要体现版本，这样方便管理和变更。 如 `v1/user/add` 。



### 向后兼容(非破坏性)的修改

- 给 API 服务定义添加 API 接口，而不是修改旧的接口，从协议的角度来看，这始终是安全的。

- 给请求消息添加字段，只要客户端在新版和旧版中对该字段的处理不保持一致，添加请求字段就是兼容的。

- 给响应消息添加字段，在不改变其他响应字段的行为的前提下，非资源（例如，*ListBooksResponse*）的响应消息可以扩展而不必破坏客户端的兼容性。



### 向后不兼容(破坏性)的修改

- 删除或重命名服务，字段，方法或枚举值。必须增加版本号。 

- 修改字段的类型，即使新类型是传输格式兼容的，这也可能会导致客户端库生成的代码发生变化，因此必须增加版本号。 

- 修改现有请求的可见行为，客户端通常依赖于 *API* 行为和语义，即使这样的行为没有被明确支持或记录。 因此，在大多数情况下，修改 *API* 数据的行为或语义将被消费者视为是破坏性的。



## API 错误

一些建议

- 不推荐全局错误码，难以约束容易冲突。
- 区分错误码，要便于监控。如果错误信息，在常规的 http body 的一个 json 里面，这意味着判定错误还需要解析 json 才能知道，这对于监控，记录错误分布，往往不是很方便。可以尝试这把错误码收敛到常规的 http 状态码里面。
- 推荐用标准的 http 2.0 的状态码。
- 不要透传错误码，吞掉下游的错误码。
- 参考 grpc 的错误码设计。
- 服务提供放可以提供错误判断包。



**不推荐全局错误码**

全局错误码，是松散、易被破坏契约的，

在每个服务传播错误的时候，做一次翻译，这样保证每个服务 `+` 错误枚举，应该是唯一的，而且在 *proto* 定义中是可以写出来文档的。



**收敛错误码**

例如，服务器没有定义不同类型的`找不到错误`，而是使用一个标准 *google.rpc.Code.NOT_FOUND* 错误代码并告诉客户端找不到哪个特定资源。状态空间变小降低了文档的复杂性，在客户端库中提供了更好的惯用映射，并降低了客户端的逻辑复杂性，同时不限制是否包含可操作信息[*/google/rpc/error_details*](https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto)。



下面是一个表格，其中包含[`google.rpc.Code`](https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto)中定义的所有gRPC错误代码及其原因的简短说明。 要处理错误，您可以检查返回状态码的描述，并相应地修改您的请求。

| HTTP | RPC                     | 描述                                                         |
| :--- | :---------------------- | :----------------------------------------------------------- |
| 200  | **OK**                  | 没有错误                                                     |
| 400  | **INVALID_ARGUMENT**    | 客户端指定了无效的参数。 检查错误消息和错误详细信息以获取更多信息。 |
| 400  | **FAILED_PRECONDITION** | 请求不能在当前系统状态下执行，例如删除非空目录。             |
| 400  | **OUT_OF_RANGE**        | 客户端指定了无效的范围。                                     |
| 401  | **UNAUTHENTICATED**     | 由于遗失，无效或过期的OAuth令牌而导致请求未通过身份验证。    |
| 403  | **PERMISSION_DENIED**   | 客户端没有足够的权限。这可能是因为OAuth令牌没有正确的范围，客户端没有权限，或者客户端项目尚未启用API。 |
| 404  | **NOT_FOUND**           | 找不到指定的资源，或者该请求被未公开的原因（例如白名单）拒绝。 |
| 409  | **ABORTED**             | 并发冲突，例如读-修改-写冲突。                               |
| 409  | **ALREADY_EXISTS**      | 客户端尝试创建的资源已存在。                                 |
| 429  | **RESOURCE_EXHAUSTED**  | 资源配额达到速率限制。 客户端应该查找google.rpc.QuotaFailure错误详细信息以获取更多信息。 |
| 499  | **CANCELLED**           | 客户端取消请求                                               |
| 500  | **DATA_LOSS**           | 不可恢复的数据丢失或数据损坏。 客户端应该向用户报告错误。    |
| 500  | **UNKNOWN**             | 未知的服务器错误。 通常是服务器错误。                        |
| 500  | **INTERNAL**            | 内部服务错误。 通常是服务器错误。                            |
| 501  | **NOT_IMPLEMENTED**     | 服务器未实现该API方法。                                      |
| 503  | **UNAVAILABLE**         | 暂停服务。通常是服务器已经关闭。                             |
| 504  | **DEADLINE_EXCEEDED**   | 已超过请求期限。如果重复发生，请考虑降低请求的复杂性。       |



### 错误处理

**错误传播**

如果 *API* 服务依赖于其他服务，则不应盲目地将这些服务的错误传播到客户端。在翻译错误时，建议执行以下操作：

- 隐藏实现详细信息和机密信息。
- 例如，从另一个服务接收 *INVALID_ARGUMENT* 错误的服务器应该将 *INTERNAL* 传播给它自己的调用者。



**grpc 服务之间错误处理范例**

errors deep copy 挂在到 grpc 传给调用方，调用方在调用 kit组件判断错误类型，并获取错误信息 

- app error -> grpc error -> app error 通过grpc 点插件来处理

